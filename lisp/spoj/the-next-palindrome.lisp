(defun less (v1 v2)
  (let ((l1 (length v1))
        (l2 (length v2)))
    (cond ((< l1 l2) t)
          ((> l1 l2) nil)
          (t (do ((i 0 (+ i 1)))
               ((>= i l1) t)
               (if (> (elt v1 i) (elt v2 i)) (return-from less nil)))))))


(defun make-palindrome (v i j)
  (let ((ret (make-array (length v) :element-type 'integer)))
    (loop
      (when (< i 0) (return))
      (setf (elt ret i) (elt v i))
      (setf (elt ret j) (elt v i))
      (decf i)
      (incf j)) ret))

(defun adjust (v i j)
  (let* ((p i)
         (sum (+ (elt v p) 1))
         (carry (truncate (/ sum 10))))
    (setf (elt v p) (mod sum 10))
    (decf p)
    (loop
      (when (or (< p 0) (= carry 0)) (return))
      (setf sum (+ (elt v p) carry))
      (setf (elt v p) (mod sum 10))
      (setf carry (truncate (/ carry 10)))
      (decf p))
    (make-palindrome v i j)))

(defun do-solve (v)
   (let ((ret (make-array 1 :fill-pointer 0 :adjustable t :element-type 'integer)))
     (vector-push-extend 1 ret)
     (dotimes (n (- (length v) 1))
       (vector-push-extend 0 ret))
     (vector-push-extend 1 ret)
     ret))

(defun solve (v)
  (if (= (count 9 v) (length v))
    (do-solve v)
    (let ((len (length v))
          (i 0)
          (j 0))
      (if (evenp len)
        (setf i (truncate (- (/ len 2) 1)) j (+ i 1))
        (setf i (truncate (/ len 2)) j i))
      (let ((ret (make-palindrome v i j)))
        (loop
          (when (not (less ret v)) (return))
          (setf ret (adjust ret i j))) ret))))

(defun show (v)
  (do ((i 0 (+ i 1)))
    ((>= i (length v)) (format t "~%"))
    (format t "~a" (elt v i))))

(defun cast-to-vector (exp)
  (let ((v (make-array 1 :fill-pointer 0 :adjustable t :element-type 'integer)))
    (do ((i 0 (+ i 1)))
      ((>= i (length exp)) v)
      (vector-push-extend  (digit-char-p (elt exp i))  v))))

(dotimes (cases (read-from-string (read-line)))
  (let ((exp (read-line)))
    (show (solve (cast-to-vector exp)))))
